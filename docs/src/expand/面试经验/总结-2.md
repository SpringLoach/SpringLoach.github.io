#### Part1

1. Vuex 和 Pinia 有什么区别

① Pinia 会更接近组合式 API 的设计理念

② 且原生提供对 TypeScript 支持

③ API 更简洁，去除了 mutations 和 modules，剩余 state, getters 和 actions

④ 不再使用嵌套模块，而是采用扁平化的 store，并且支持 store 间的交叉组合



2. webpack常用配置

① 使用 entry 和 output，对入口和出口进行配置，比如指定输出目录或对输出文件名进行内容哈希处理

② （通过 mode）可以配置开发或生产模式

③ 可以添加 loader，对资源进一步处理，比如用babel处理js文件，用postcss处理样式，处理图片和文字的路径等

④ 可以使用插件

- 自动生成 `index.html` ，并自动注入打包后的 JS/CSS
- 在每次构建前清理 `dist` 目录
- 可视化分析打包体积

⑤ 可以配置开发服务器，设置启动端口，配置代理的目标地址

⑥ 可以进行解析配置，比如设置自动解析的文件扩展名顺序，配置路径别名

⑦ 可以进行优化配置，比如设置分包的规则，启用Tree Shaking，进行压缩配置等

⑧ 可以通过 `webpack-merge` 库将开发环境和生成环境的公共配置进行提取



3. 优化方面有做哪些努力

① 有一部分的老项目使用 webpack 构建的，在启动和部署时都非常地慢。我们就升级对应的 vue 版本，然后将构建工具替换为 vite，并对一些语法进行适配，最终迁移成功，启动时间从几分钟压缩至秒级，极大地提升了开发体验。

② 解决内存泄漏的问题，除了删除生产环境的 `console.log` 外，还在组件卸载前补充对定时器、事件监听程序和第三方实例的销毁

③ 订单详情页是一个很早就开发了的，并被迭代了无数次的页面。很多的弹窗或表单都被写到了详情页组件文件中，都耦合在一起，代码量多维护起来很不方便。另一方面，即便有部分组件进行了单独封装，都是在组件内部的最外层使用 `v-if` 控制显隐，这就导致很多多余的变量和方法都会被加载，造成内存浪费。我们就将代码进行抽离，将条件放到最外层，并改写为组件懒加载的写法，显著解决页面内存占用过多的问题。

④ 有一个H5项目，它已经迭代好几年了，体积较大而且启动时间较慢，然后我对它的打包体积进行可视化分析，发现了一些废弃或重复的依赖，比如它引入了 jquery 的不同版本。于是我就去排查项目中到底有没有使用到一些依赖，并从入口文件 `index.html` 和 `main.js` 中筛选那些不需要在初始页面马上注入的脚本，去修改它们的引入位置。最终实现初始加载速度提高一倍，初始请求数量减半。

⑤  我还对小程序项目进行了用户体验方面的优化，比如为主要的几个tab页面添加骨架屏，另外由于在接口底层设置了每次都会添加loading效果，而首页的接口数量较多，会出现 loading 的多次闪烁，我就将后续不影响展示的接口单独设置为不添加loading

⑥ 另外对一些已有的不合理交互，我跟产品提出了优化建议。比如一个页面存在若干个选择器，而每个选择器中的下拉选项又有成千上万个，就非常容易造成性能浪费的问题。可以改变它的交互方式为弹窗选择等。



5. 白屏常见原因，解决方案

① 初始体积过大，耗时逻辑过多

② 浏览器兼容性问题，比如使用ES6+语法，代码未做好兼容，在旧浏览器运行报错

③ 路径匹配错误，或是使用 history 模式未配置服务器支持

④ JavaScript 执行错误，比如使用了未定义的变量等，导致 Vue 未挂载、React 渲染出错



7. 大屏项目怎么实现，有遇到过卡顿问题吗，怎么解决

① 对于超多数据的列表，采用虚拟滚动的技术实现，只渲染可视区域内的数据

② 有些定时动画，比如 echart 的饼图，想要实现自动遍历突出的效果，就可以使用 requestAnimationFrame：替代 setTimeout / setInterval，有更好的性能表现

③ 有些滚动的动画，使用 `transform` 替代  `top`/`left` 这种定位属性，后者会导致频繁的回流



8. 如何提取Hooks

① 首先要对普通方法和hook进行区分

② 在 Vue 中体现为依赖的响应式系统的逻辑（如`ref`/`reactive`/`watch`）

③ 在 React 中体现为调用其他Hook的逻辑（如 `useState`、`useEffect`）

④ 自定义 hook 命名使用 `use` 作为前缀

⑤ 对于多个组件间的共享逻辑，可以有意识地抽离，如结合 localStorage 实现持久化状态

⑥ 对于复杂组件，可以考虑将逻辑进行拆分

⑦ Hook 应该遵循单一职责，即只做一件事，比如埋点、初始化请求、给dom节点订阅事件，就应该分为不同的 Hook。



9. 多并发请求，如何处理

① 处理多并发请求时，我会根据场景选择不同方案

② 对于少量独立请求，直接用 `Promise.all` 或 `Promise.allSettled`，后者不在乎请求结果是成功或失败；

③ 对于大批量请求，通过 `p-limit` 或手动实现并发池控制并发数，避免浏览器瓶颈（适用于批量上传、分页数据预加载等场景）；

④ 在实时交互场景（如搜索），用 `AbortController` 取消旧请求；

⑤ 对重复请求，可以判断参数是否有差异，引入缓存优化性能。



10. 返回大量数据如何处理

① 实现分页查询，减少单次请求数据量；

② 采用虚拟滚动的技术，仅渲染可视区域内容；

③ 如果数据涉及到较大的计算量，可以使用 `web worker` 将计算逻辑抽离到其他线程执行，避免阻塞渲染。



11.  能否接受加班

① 互联网行业是会有一定的加班的。之前做万宁项目时，也曾为赶进度连续两周工作到10点，最终保证了版本如期交付。

② 像项目上线、紧急故障处理这种必要情况，我会主动配合团队完成任务。



12. webpack在构建方面有哪些优化配置

一、减少打包体积

① 可以对js和css代码进行压缩；

② 采用代码分割将第三方库分离；

③ 使用 Tree Shaking（使用 ES Module 而非 CommonJS）；

④ 使用按需加载的语法 `import()`

二、加快构建速度

① 使用持久化缓存

② 指定扩展名、使用 loader 时排除依赖包从而 缩小文件搜索范围

③ 用 esbuild 替代 Terser

三、提升运行时性能

① 预加载首屏关键资源

② 对文件名进行内容哈希处理

③ 通过 CDN 引入第三方依赖，如 React

四、其他

① 可视化分析包内容

② 移除无用代码

③ 进行图片压缩等



#### Part2

1. `useState` 和 `useEffect` 的使用场景？如何模拟 `componentDidMount`？

   ① `useState` 用于在函数组件中管理局部状态，当状态变化时触发组件重新渲染

   ② `useEffect` 用于处理副作用[与组件渲染结果无关的任何操作]（如数据获取、DOM 操作、订阅事件等）

   ③ 通过添加空依赖数组模拟 `componentDidMount` （组件挂载后执行）

   ④ 不提供依赖数组，会在每次渲染时都执行

   ⑤ 通过指定依赖项，`useEffect` 会在依赖变化时执行，模拟 `componentDidUpdate`

   ⑥ 在 `useEffect` 的 清理函数（返回值） 中执行卸载逻辑，模拟 `componentWillUnmount`



2. 如何在 `useEffect` 中调用 `async/await`

由于 `useEffect` 的回调函数不能直接是 `async`，需要内部定义异步函数，然后手动调用。



3. 如何解决 `useEffect` 的闭包问题

   ① 方法一：添加依赖项，在它变化时每次变化时重新执行

   ② 方法二：使用 `useRef` 存储最新值（适用于不想重新触发 `useEffect` 的情况）

   ③ 在异步操作中，使用 `useRef` 存储最新值，或使用 `setState` 的函数式更新形式



4. `useMemo` vs `useCallback` 的区别

   ① `useMemo` 用于缓存复杂计算的结果，可以避免子组件因无关 `props` 变化而重新渲染；

   ② `useCallback` 用于缓存 函数本身，避免因函数引用变化导致子组件无效渲染。适用于将函数作为 `props` 传递给子组件时。

   ③ 结合 `React.memo` 可以避免子组件无效渲染。



5. React vs Vue

① React 使用 JSX 作为模板语法（将 js 和 html 混合），而 Vue 使用单文件组件（html + js + css）

② 在数据绑定方面，React 遵循单向数据流，Vue 的话，还能通过 v-model 实现双向绑定

③ 组件通信，React 使用 `Props` + 回调 / Context API，Vue 使用`Props` + 事件 / Provide/Inject

④ 两种都采用了虚拟 DOM 的方案，但 Vue 运用的是更细粒度的依赖追踪，React 用的 Fiber 架构

⑤ Vue 自动追踪依赖从而更新组件，React 需要手动优化（`React.memo`）

⑥ Vue 的官方对路由和状态管理提供了解决方案，而 React 灵活度更高，可以手动选择状态管理方案

⑦ 大型复杂应用倾向 React，快速开发倾向 Vue



6. 生命周期方法的执行顺序

| **类组件生命周期**      | **函数组件等价实现**      | 执行时机                   |
| :---------------------- | :------------------------ | :------------------------- |
| `constructor`           | `useState` 初始化         | 组件首次渲染               |
| `componentDidMount`     | `useEffect(() => {}, [])` | 挂载完成（依赖项为空数组） |
| `componentDidUpdate`    | `useEffect(() => {})`     | 每次渲染后（无依赖项）     |
| `componentWillUnmount`  | `useEffect` 的清理函数    | 组件卸载前                 |
| `shouldComponentUpdate` | `React.memo` + `useMemo`  | 父组件渲染时               |

```
首次渲染:
  useState → render → useEffect（空依赖）

更新:
  useState → render → useEffect（无依赖或依赖变化）

卸载:
  useEffect 清理函数
```



7. 为什么 `componentWillUnmount` 适合清理副作用

在组件被销毁前触发，组件内部的事件监听、第三方实例、定时函数已经没有意义，但不手动销毁会因为存在引用关系而无法触发垃圾回收，导致内存泄漏



8. React 的 Diff 算法原理？key 的作用？

一、Diff 算法有几个关键点：

① **分层比较：**对同一层级的节点进行比较，不跨层级移动节点

② **组件比较：**相同类型的组件会继续递归比较其子节点，不同类型则直接替换

③ **列表比较：**通过 `key` 匹配新旧列表中的相同项

二、key 的核心作用

① 通过 `key` 识别新旧虚拟 DOM 中的对应节点，决定到底时复用还是新建节点

② 不能使用索引作为 `key`，否则会导致不必要的 DOM 更新，造成性能下降，甚至引发如输入框错乱的奇怪bug

三、Diff 算法与 `key` 的关系

① 当列表项顺序变化时，使用 `key` 匹配节点，从而确保节点正确复用

② 也可以通过该方式去触发子组件的重新挂载



9. redux 原理

① 它存在三大核心原则：单一数据源（来源于同个对象）、状态只读（不能直接修改）、使用纯函数修改状态（Reducer）

② 它的工作流程，首先会通过 `dispatch(action)` 发起状态变更请求，然后执行 Reducer，更新 Store，最后通知订阅了 Store 的组件获取新状态并重新渲染。



10. react-redux 原理

① 在内部定义了一个高阶组件，通过 `context` 实例保存初始化状态，并将状态传递给后端组件

② 核心在于通过`Provider` 在顶部注入 Store，通过 `useSelector` 和 `useDispatch` 的 Hooks 可以获取状态和触发 action



11. React 中如何实现父子组件通信？跨组件通信（Context API）

① 父组件可以通过 `props` 传递数据给子组件

② 可以传递一个回调函数，从而让子组件间接修改状态

③ 使用 `forwardRef` 和 `useImperativeHandle` ，可以让父调用子组件的方法

④ 使用 `Context API` 实现跨多层级组件共享状态

⑤ 使用 Redux 实现全局的状态管理

