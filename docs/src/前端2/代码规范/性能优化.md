### 实现图片预加载

> [相关资料](https://www.cnblogs.com/haoyijing/p/5818236.html)

```html
<img v-if="demo" class="demo" />

<script>
export default {
    mounted() {
        this.preload()
    },
    methods: {
        preload() {
            // 需要预加载的图片地址列表
            const target = ['https://xx.jpg']
            const images = []
            imgList.forEach((item, index) => {
                images[index] = new Image()
                images[index].src = item
            })
        }
    }
}
</script>

<style lang="scss" scoped>
.demo {
    background-image: url('https://xx.jpg');
    background-repeat: no-repeat;
    background-size: 100% 100%;
}
<style>
```



### 减少打印

过多的 `console.log`，会导致大量内存泄漏，容易导致页面卡死：一个很经典的场景，就是调试日期选择器的禁用时间。



### 页面奔溃

下拉框中存在过多的选项，也能够使页面崩溃



### vue-router缓存优化

针对keep-alive不释放内存做新的处理方式

阅读vue中keep-alive源码，发现缓存页面主要有两个属性进行控制，cache和keys

![[性能优化]内存对比](https://raw.githubusercontent.com/SpringLoach/img_store/main/img/[性能优化]内存对比.png)



### 虚拟滚动

https://juejin.cn/post/7338636024212504613

> 每移动一项的距离，刷新一次列表，但没有过渡态

```html
<template>
    <diy-dialog ref="dialogRef" title="更换客服" title-in-center width="800px">
        <!-- 虚拟列表容器，类似“窗口”，窗口的高度取决于一次展示几条数据
            比如窗口只能看到10条数据，一条40像素，10条400像素
            故，窗口的高度为400像素，注意要开定位和滚动条 -->
        <div
            class="virtualListWrap"
            ref="virtualListWrap"
            @scroll="handleScroll"
            :style="{ height: itemHeight * count + 'px' }"
        >
            <!-- 占位dom元素，其高度为所有的数据的总高度 -->
            <div class="placeholderDom" :style="{ height: allListData.length * itemHeight + 'px' }"></div>
            <!-- 内容区，展示10条数据，注意其定位的top值是变化的 -->
            <div class="contentList" :style="{ top: topVal }">
                <!-- 每一条（项）数据 -->
                <div
                    v-for="(item, index) in showListData"
                    :key="index"
                    class="itemClass"
                    :style="{ height: itemHeight + 'px' }"
                >
                    {{ item.name }}
                </div>
            </div>
            <!-- 加载中部分 -->
            <div class="loadingBox" v-show="loading">
                <i class="el-icon-loading"></i>
                &nbsp;&nbsp;<span>loading...</span>
            </div>
        </div>
    </diy-dialog>
</template>

<script>
import diyDialog from '@/components/diyDialog'

export default {
    components: {
        diyDialog
    },
    data() {
        return {
            allListData: [], // 所有的数据，比如这个数组存放了十万条数据
            itemHeight: 40, // 每一条（项）的高度，比如40像素
            count: 10, // 一屏展示几条数据
            start: 0, // 开始位置的索引
            end: 10, // 结束位置的索引
            topVal: 0, // 父元素滚动条滚动，更改子元素对应top定位的值，确保联动
            loading: false
        }
    },

    computed: {
        // 从所有的数据allListData中截取需要展示的数据showListData
        showListData: function () {
            return this.allListData.slice(this.start, this.end)
        }
    },
    async created() {
        this.loading = true
        
        setTimeout(() => {
            this.allListData = [
                {name: 1},
                {name: 2},
                {name: 3},
                {name: 4},
                {name: 5},
                {name: 6},
                {name: 7},
                {name: 8},
                {name: 9},
                {name: 10},
                {name: 11},
                {name: 12},
                {name: 13},
                {name: 14},
                {name: 15},
                {name: 16},
                {name: 17},
                {name: 18},
            ]
            this.loading = false
        }, 2000)
    },

    methods: {
        showDialog() {
            this.$refs.dialogRef.showDialog()
        },
        // 滚动这里可以加上节流，减少触发频次
        handleScroll() {
            const scrollTop = this.$refs.virtualListWrap.scrollTop
            this.start = Math.floor(scrollTop / this.itemHeight)
            this.end = this.start + this.count
            this.topVal = this.$refs.virtualListWrap.scrollTop + 'px'
        }
    }
}
</script>

<style lang="scss" scoped>
.virtualListWrap {
    position: relative;
    overflow: auto;
    .contentList {
        position: absolute;
    }
}
</style>
```

`改良`

> 渲染数量+1，但可以有视觉上的下拉过渡效果

```javascript
handleScroll() {
    const scrollTop = this.$refs.virtualListWrap.scrollTop
    const res = scrollTop % this.itemHeight // [!code highlight]
    this.start = Math.floor(scrollTop / this.itemHeight)
    this.end = this.start + this.count + 1 // [!code highlight]
    this.topVal = (this.$refs.virtualListWrap.scrollTop - res) + 'px' // [!code highlight]
}
```

